{"version":3,"sources":["webpack://BCI2K/webpack/universalModuleDefinition","webpack://BCI2K/./bci2k.ts","webpack://BCI2K/external \"websocket\"","webpack://BCI2K/webpack/bootstrap","webpack://BCI2K/webpack/startup"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__913__","websocket","BCI2K_DataConnection","address","_socket","onconnect","onGenericSignal","data","onStateVector","onSignalProperties","onStateFormat","ondisconnect","onReceiveBlock","callingFrom","states","signal","signalProperties","stateFormat","stateVecOrder","SignalType","INT16","FLOAT24","FLOAT32","INT32","dv","val","count","byteLength","v","getUint8","String","fromCharCode","connection","undefined","Promise","resolve","reject","binaryType","onerror","onopen","onclose","e","setTimeout","console","log","connect","onmessage","event","_decodeMessage","readyState","OPEN","descriptor","DataView","stateFormatView","_decodeStateFormat","supplement","genericSignalView","_decodeGenericSignal","signalPropertyView","_decodeSignalProperties","error","toString","stateVectorView","_decodeStateVector","unitstr","units","unit","split","idx","offset","Number","gain","symbol","vmin","vmax","propstr","getNullTermString","replace","prop_tokens","props","i","length","trim","push","pidx","name","channels","numChannels","parseInt","elements","numElements","numelements","signaltype","channelunit","_decodePhysicalUnits","slice","join","elementunit","valueunits","lines","lineIdx","stateline","bitWidth","defaultValue","byteLocation","bitLocation","vecOrder","state","loc","sort","a","b","index","signalType","nChannels","getUint16","nElements","byteOffset","signalData","buffer","ch","el","getInt16","getFloat32","getInt32","i8Array","Int8Array","firstZero","indexOf","secondZero","decoder","TextDecoder","stateVectorLength","decode","numVectors","Array","fill","vecIdx","vec","Uint8Array","bits","byteIdx","stateIdx","fmt","mask","bIdx","bciOperator","onStateChange","_execid","_exec","opcode","id","contents","JSON","parse","location","locationParameter","execute","then","dataConnection","instruction","connected","exec","send","stringify","x","ip","port","setInterval","allData","forEach","line","descriptors","dataType","names","value","low","high","comment","bciData","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"websocket\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"websocket\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"BCI2K\"] = factory(require(\"websocket\"));\n\telse\n\t\troot[\"BCI2K\"] = factory(root[\"websocket\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__913__) {\nreturn ","// ======================================================================== //\n//\n// bci2k.js\n// A javascript connector for BCI2000\n//\n// ======================================================================== //\n\n//To see how the BCI2000 messages are implemented in BCI2000 see here:\n// https://www.bci2000.org/mediawiki/index.php/Technical_Reference:BCI2000_Messages\n\nconst websocket = require(\"websocket\").w3cwebsocket;\n\nclass BCI2K_OperatorConnection {\n  websocket: WebSocket;\n  _execid: any;\n  _exec: any;\n  state: any;\n  ondisconnect: any;\n  onStateChange: any;\n  address: string;\n\n  constructor(address?: string) {\n    this.ondisconnect = () => {};\n    this.onStateChange = (event: string) => {};\n\n    // this.websocket = null;\n    this._execid = 0;\n    this._exec = {};\n    this.state = \"\";\n    this.address = address;\n  }\n\n  public connect(address?: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (this.address === undefined) {\n        this.address =\n          address || \"ws://127.0.0.1:80\" || `ws://{window.location.host}`;\n      }\n\n      this.websocket = new websocket(this.address);\n\n      this.websocket.onerror = (error) => {\n        // This will only execute if we err before connecting, since\n        // Promises can only get triggered once\n        reject(\"Error connecting to BCI2000 at \" + this.address);\n      };\n\n      this.websocket.onopen = () => {\n        resolve();\n      };\n\n      this.websocket.onclose = () => {\n        this.ondisconnect();\n      };\n\n      this.websocket.onmessage = (event) => {\n        let { opcode, id, contents } = JSON.parse(event.data);\n        switch (opcode) {\n          case \"O\": // OUTPUT: Received output from command\n            this._exec[id](contents);\n            delete this._exec[id];\n            break;\n          default:\n            break;\n        }\n      };\n    });\n  }\n\n  public tap(location: string) {\n    let connection = this;\n\n    let locationParameter = \"WS\" + location + \"Server\";\n\n    return this.execute(\"Get Parameter \" + locationParameter).then(\n      (location: string) => {\n        if (location.indexOf(\"does not exist\") >= 0) {\n          return Promise.reject(\"Location parameter does not exist\");\n        }\n        if (location === \"\") {\n          return Promise.reject(\"Location parameter not set\");\n        }\n\n        let dataConnection = new BCI2K_DataConnection();\n\n        // Use our address plus the port from the result\n        return dataConnection\n          .connect(connection.address + \":\" + location.split(\":\")[1], \"\")\n          .then((event) => {\n            // To keep with our old API, we actually want to wrap the\n            // dataConnection, and not the connection event\n            // TODO This means we can't get the connection event!\n            return dataConnection;\n          });\n      }\n    );\n  }\n\n  public connected() {\n    return (\n      this.websocket !== null && this.websocket.readyState === websocket.OPEN\n    );\n  }\n\n  public execute(instruction: string) {\n    let connection = this;\n    if (this.connected()) {\n      return new Promise((resolve, reject) => {\n        let id = (++connection._execid).toString();\n        // TODO Properly handle errors from BCI2000\n        connection._exec[id] = (exec) => resolve(exec);\n        connection.websocket.send(\n          JSON.stringify({\n            opcode: \"E\",\n            id: id,\n            contents: instruction,\n          })\n        );\n      });\n    }\n    // Cannot execute if not connected\n    return Promise.reject(\n      \"Cannot execute instruction: not connected to BCI2000\"\n    );\n  }\n\n  getVersion() {\n    this.execute(\"Version\").then((x: string) => console.log(x.split(\" \")[1]));\n  }\n\n  showWindow() {\n    return this.execute(\"Show Window\");\n  }\n\n  hideWindow() {\n    return this.execute(\"Hide Window\");\n  }\n\n  setWatch(state: string, ip: string, port: string) {\n    return this.execute(\"Add watch \" + state + \" at \" + ip + \":\" + port);\n  }\n\n  resetSystem() {\n    return this.execute(\"Reset System\");\n  }\n\n  setConfig() {\n    return this.execute(\"Set Config\");\n  }\n\n  start() {\n    return this.execute(\"Start\");\n  }\n\n  stop() {\n    return this.execute(\"Stop\");\n  }\n\n  kill() {\n    return this.execute(\"Exit\");\n  }\n\n  stateListen() {\n    setInterval(() => {\n      this.execute(\"GET SYSTEM STATE\").then((state: string) => {\n        if (state.trim() != this.state) {\n          this.onStateChange(state.trim());\n          this.state = state.trim();\n        }\n      });\n    }, 500);\n  }\n\n  async getSubjectName() {\n    //Promise<string> {\n    return await this.execute(\"Get Parameter SubjectName\");\n  }\n\n  async getTaskName() {\n    return await this.execute(\"Get Parameter DataFile\");\n  }\n  //See https://www.bci2000.org/mediawiki/index.php/Technical_Reference:Parameter_Definition\n  async getParameters() {\n    let parameters: any = await this.execute(\"List Parameters\");\n    let allData = parameters.split(\"\\n\");\n    let data = {};\n    let el;\n    allData.forEach(line => {\n      let descriptors = line.split(\"=\")[0]\n      let dataType = descriptors.split(\" \")[1]\n      let name = descriptors.split(\" \")[2]\n      let names = descriptors.split(\" \")[0].split(\":\");\n      names.forEach((x, i) =>{\n        switch(i){\n          case 0: {\n            if(data[names[0]]==undefined){\n              data[names[0]] = {}\n            }\n            el = data[names[0]]\n            break;\n          }\n          case 1: {\n            if(data[names[0]][names[1]]==undefined){\n            data[names[0]][names[1]] ={}\n            }\n            el = data[names[0]][names[1]]\n            break;\n          }\n          case 2: {\n            if(data[names[0]][names[1]][names[2]]==undefined){\n            data[names[0]][names[1]][names[2]] ={}\n            }\n            el = data[names[0]][names[1]][names[2]]\n            break;\n          }\n            default: {}\n          }\n      })\n\n      if(dataType != \"matrix\"){\n        if(line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \").length == 4){\n          el[name] = {\n            dataType,\n            value: {\n              value: line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \")[0],\n              defaultValue: line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \")[1],\n              low:line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \")[2],\n              high:line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \")[3],\n            },\n            comment: line.split(\"=\")[1].split(\"//\")[1]\n          }\n        }\n        else{\n          el[name] = {\n            dataType,\n            value: line.split(\"=\")[1].split(\"//\")[0].trim(),\n            comment: line.split(\"=\")[1].split(\"//\")[1]\n        }\n      }\n      }\n      else{\n        el[name] = {\n          dataType,\n          value: line.split(\"=\")[1].split(\"//\")[0].trim(),\n          comment: line.split(\"=\")[1].split(\"//\")[1]\n        }  \n      }\n\n    });\n\n    return data\n  }\n}\n\nclass BCI2K_DataConnection {\n  _socket: WebSocket;\n  states: any;\n  signal: any;\n  signalProperties: any;\n  stateFormat: any;\n  stateVecOrder: any;\n  SignalType: any;\n  callingFrom: any;\n  onconnect: any;\n  onGenericSignal: any;\n  onStateVector: any;\n  onSignalProperties: any;\n  onStateFormat: any;\n  ondisconnect: any;\n  onReceiveBlock: any;\n  address: string;\n  constructor(address?: string) {\n    this._socket = null;\n\n    this.onconnect = () => {};\n    this.onGenericSignal = (data: any) => {};\n    this.onStateVector = (data: any) => {};\n    this.onSignalProperties = (data: any) => {};\n    this.onStateFormat = (data: any) => {};\n    this.ondisconnect = () => {};\n    this.onReceiveBlock = () => {};\n\n    this.callingFrom = \"\";\n\n    this.states = {};\n    this.signal = null;\n    this.signalProperties = null;\n    this.stateFormat = null;\n    this.stateVecOrder = null;\n\n    this.SignalType = {\n      INT16: 0,\n      FLOAT24: 1,\n      FLOAT32: 2,\n      INT32: 3,\n    };\n    this.address = address;\n  }\n\n  private getNullTermString(dv: DataView) {\n    var val = \"\";\n    let count = 0;\n    while (count < dv.byteLength) {\n      var v = dv.getUint8(count);\n      count++;\n      if (v == 0) break;\n      val += String.fromCharCode(v);\n    }\n    return val;\n  }\n\n  connect(address?: string, callingFrom?: string) {\n    let connection = this;\n    if (connection.address === undefined) connection.address = address;\n    this.callingFrom = callingFrom;\n    return new Promise<void>((resolve, reject) => {\n      connection._socket = new websocket(connection.address);\n      connection._socket.binaryType = \"arraybuffer\";\n\n      connection._socket.onerror = () => {\n        // This will only execute if we err before connecting, since\n        // Promises can only get triggered once\n        reject(\"Error connecting to data source at \" + connection.address);\n      };\n\n      connection._socket.onopen = () => {\n        connection.onconnect();\n        resolve();\n      };\n\n      connection._socket.onclose = (e) => {\n        connection.ondisconnect();\n        setTimeout(() => {\n          console.log(\"Disconnected\");\n          this.connect(\"\");\n        }, 1000);\n      };\n\n      connection._socket.onmessage = (event) => {\n        connection._decodeMessage(event.data);\n      };\n    });\n  }\n\n  connected(): boolean {\n    return this._socket != null && this._socket.readyState === websocket.OPEN;\n  }\n\n  private _decodeMessage(data: ArrayBuffer) {\n    let descriptor = new DataView(data, 0, 1).getUint8(0);\n    switch (descriptor) {\n      case 3:\n        let stateFormatView = new DataView(data, 1, data.byteLength - 1);\n        this._decodeStateFormat(stateFormatView);\n        break;\n\n      case 4:\n        let supplement = new DataView(data, 1, 2).getUint8(0);\n        switch (supplement) {\n          case 1:\n            let genericSignalView = new DataView(data, 2, data.byteLength - 2);\n            this._decodeGenericSignal(genericSignalView);\n            break;\n          case 3:\n            let signalPropertyView = new DataView(data, 2, data.byteLength - 2);\n            this._decodeSignalProperties(signalPropertyView);\n            break;\n          default:\n            console.error(\"Unsupported Supplement: \" + supplement.toString());\n            break;\n        }\n        this.onReceiveBlock();\n\n        break;\n\n      case 5:\n        let stateVectorView = new DataView(data, 1, data.byteLength - 1);\n        this._decodeStateVector(stateVectorView);\n        break;\n\n      default:\n        console.error(\"Unsupported Descriptor: \" + descriptor.toString());\n        break;\n    }\n  }\n\n  private _decodePhysicalUnits(unitstr: string) {\n    let units: any;\n    units = {};\n    let unit = unitstr.split(\" \");\n    let idx = 0;\n    units.offset = Number(unit[idx++]);\n    units.gain = Number(unit[idx++]);\n    units.symbol = unit[idx++];\n    units.vmin = Number(unit[idx++]);\n    units.vmax = Number(unit[idx++]);\n    return units;\n  }\n\n  private _decodeSignalProperties(data: DataView) {\n    let propstr = this.getNullTermString(data);\n    // Bugfix: There seems to not always be spaces after '{' characters\n    propstr = propstr.replace(/{/g, \" { \");\n    propstr = propstr.replace(/}/g, \" } \");\n\n    this.signalProperties = {};\n    let prop_tokens = propstr.split(\" \");\n    let props = [];\n    for (let i = 0; i < prop_tokens.length; i++) {\n      if (prop_tokens[i].trim() === \"\") continue;\n      props.push(prop_tokens[i]);\n    }\n\n    let pidx = 0;\n    this.signalProperties.name = props[pidx++];\n\n    this.signalProperties.channels = [];\n    if (props[pidx] === \"{\") {\n      while (props[++pidx] !== \"}\")\n        this.signalProperties.channels.push(props[pidx]);\n      pidx++; // }\n    } else {\n      let numChannels = parseInt(props[pidx++]);\n      for (let i = 0; i < numChannels; i++)\n        this.signalProperties.channels.push((i + 1).toString());\n    }\n\n    this.signalProperties.elements = [];\n    if (props[pidx] === \"{\") {\n      while (props[++pidx] !== \"}\")\n        this.signalProperties.elements.push(props[pidx]);\n      pidx++; // }\n    } else {\n      let numElements = parseInt(props[pidx++]);\n      for (let i = 0; i < numElements; i++)\n        this.signalProperties.elements.push((i + 1).toString());\n    }\n\n    // Backward Compatibility\n    this.signalProperties.numelements = this.signalProperties.elements.length;\n    this.signalProperties.signaltype = props[pidx++];\n    this.signalProperties.channelunit = this._decodePhysicalUnits(\n      props.slice(pidx, (pidx += 5)).join(\" \")\n    );\n\n    this.signalProperties.elementunit = this._decodePhysicalUnits(\n      props.slice(pidx, (pidx += 5)).join(\" \")\n    );\n\n    pidx++; // '{'\n\n    this.signalProperties.valueunits = [];\n    for (let i = 0; i < this.signalProperties.channels.length; i++)\n      this.signalProperties.valueunits.push(\n        this._decodePhysicalUnits(props.slice(pidx, (pidx += 5)).join(\" \"))\n      );\n\n    pidx++; // '}'\n    this.onSignalProperties(this.signalProperties);\n  }\n\n  private _decodeStateFormat(data: DataView) {\n    this.stateFormat = {};\n    let formatStr = this.getNullTermString(data);\n\n    let lines = formatStr.split(\"\\n\");\n    for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {\n      if (lines[lineIdx].trim().length === 0) continue;\n      let stateline = lines[lineIdx].split(\" \");\n      let name = stateline[0];\n      this.stateFormat[name] = {};\n      this.stateFormat[name].bitWidth = parseInt(stateline[1]);\n      this.stateFormat[name].defaultValue = parseInt(stateline[2]);\n      this.stateFormat[name].byteLocation = parseInt(stateline[3]);\n      this.stateFormat[name].bitLocation = parseInt(stateline[4]);\n    }\n\n    let vecOrder = [];\n    for (let state in this.stateFormat) {\n      let loc = this.stateFormat[state].byteLocation * 8;\n      loc += this.stateFormat[state].bitLocation;\n      vecOrder.push([state, loc]);\n    }\n\n    // Sort by bit location\n    vecOrder.sort((a, b) => (a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0));\n\n    // Create a list of ( state, bitwidth ) for decoding state vectors\n    this.stateVecOrder = [];\n    for (let i = 0; i < vecOrder.length; i++) {\n      let state = vecOrder[i][0];\n      this.stateVecOrder.push([state, this.stateFormat[state].bitWidth]);\n    }\n\n    this.onStateFormat(this.stateFormat);\n  }\n\n  private _decodeGenericSignal(data: DataView) {\n    let index = 0;\n    let signalType = data.getUint8(index);\n    index = index + 1;\n    let nChannels = data.getUint16(index, true);\n    index = index + 2;\n    let nElements = data.getUint16(index, true);\n    index = index + 2;\n    index = index + data.byteOffset;\n    let signalData = new DataView(data.buffer, index);\n    let signal = [];\n    for (let ch = 0; ch < nChannels; ++ch) {\n      signal.push([]);\n      for (let el = 0; el < nElements; ++el) {\n        switch (signalType) {\n          case this.SignalType.INT16:\n            signal[ch].push(\n              signalData.getInt16((nElements * ch + el) * 2, true)\n            );\n            break;\n\n          case this.SignalType.FLOAT32:\n            signal[ch].push(\n              signalData.getFloat32((nElements * ch + el) * 4, true)\n            );\n            break;\n\n          case this.SignalType.INT32:\n            signal[ch].push(\n              signalData.getInt32((nElements * ch + el) * 4, true)\n            );\n            break;\n\n          case this.SignalType.FLOAT24:\n            // TODO: Currently Unsupported\n            signal[ch].push(0.0);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    this.signal = signal;\n    this.onGenericSignal(signal);\n  }\n\n  private _decodeStateVector(dv: DataView) {\n    if (this.stateVecOrder == null) return;\n    // Currently, states are maximum 32 bit unsigned integers\n    // BitLocation 0 refers to the least significant bit of a byte in the packet\n    // ByteLocation 0 refers to the first byte in the sequence.\n    // Bits must be populated in increasing significance\n \n    let i8Array = new Int8Array(dv.buffer);\n    let firstZero = i8Array.indexOf(0);\n    let secondZero = i8Array.indexOf(0,firstZero+1);\n\n    let decoder = new TextDecoder();\n    let stateVectorLength = parseInt(decoder.decode(i8Array.slice(1,firstZero)))\n    let numVectors = parseInt(decoder.decode(i8Array.slice(firstZero+1, secondZero)))\n\n    let index = secondZero+1;\n\n    let data = new DataView(dv.buffer, index);\n    let states = {};\n    for (let state in this.stateFormat) {\n      states[state] = Array(numVectors).fill(\n        this.stateFormat[state].defaultValue\n      );\n    }\n    for (let vecIdx = 0; vecIdx < numVectors; vecIdx++) {\n      let vec = new Uint8Array(\n        data.buffer,\n        data.byteOffset + vecIdx * stateVectorLength,\n        stateVectorLength\n      );\n      let bits = [];\n      for (let byteIdx = 0; byteIdx < vec.length; byteIdx++) {\n        bits.push((vec[byteIdx] & 0x01) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x02) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x04) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x08) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x10) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x20) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x40) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x80) !== 0 ? 1 : 0);\n      }\n\n      for (let stateIdx = 0; stateIdx < this.stateVecOrder.length; stateIdx++) {\n        let fmt = this.stateFormat[this.stateVecOrder[stateIdx][0]];\n        let offset = fmt.byteLocation * 8 + fmt.bitLocation;\n        let val = 0;\n        let mask = 0x01;\n        for (let bIdx = 0; bIdx < fmt.bitWidth; bIdx++) {\n          if (bits[offset + bIdx]) val = (val | mask) >>> 0;\n          mask = (mask << 1) >>> 0;\n        }\n        states[this.stateVecOrder[stateIdx][0]][vecIdx] = val;\n      }\n    }\n    this.onStateVector(states);\n    this.states = states;\n  }\n}\n\nmodule.exports = {\n  bciOperator: BCI2K_OperatorConnection,\n  bciData: BCI2K_DataConnection,\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__913__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(463);\n"],"sourceRoot":""}